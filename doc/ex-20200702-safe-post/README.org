#+TITLE: Learning Exercise: Post-Money SAFE

* Background

https://www.ycombinator.com/documents/

** How Complex Are SAFEs?

People like to say SAFEs become a hairball after a startup has done more than a few. Is that true? Does the complexity of SAFEs scale linearly, quadratically, or exponentially? By the end of this exercise you'll know enough to see why: the definitions are mutually recursive, and require solving simultaneous equations -- in the presence of rounding errors! But this is good for us, because it naturally lets us bring constraint solvers on-stage.

* Two Approaches: Basic Operational vs Advanced Declarative

Investors want to know: "after conversion, how much of the company will I own?" The company has to answer that question for each SAFE investor. And it has to take those answers into account when, during the Series A financing, the company sets up an option pool and deals with new investors.

The Basic Approach section shows how a computer can help to answer the question. In that section, we will do nothing more conceptually complicated than high-school algebra. We are just showing our reasoning in software instead of on paper. This is an /operational/ exercise. We will perform this exercise in Haskell, DMN, Curry, and Python, to produce code that, dealing with a specific instance of a company with SAFEs and a Series A coming up, is able to give the same answers as you would have gotten using a calculator or a spreadsheet.

One goal of this "programming chrestomathy" is to show how different languages and programming paradigms treat certain problems. The Haskell approach showcases the strengths of types. The Curry approach highlights constraints and logic. The DMN approach makes it easy to follow the data flow and visually compare the different variants of the safe. The Python version is relatable and motivates the idea of model-based code generation.

But operational implementation is only one part of what computational law is really about. In computational law, abstraction is our friend and motivator. Abstraction encourages us to write operational SAFE code which can handle the whole /class/ of SAFE problems, of which the examples in Appendix II are individual /instances/. Next, abstraction pushes us one level higher: it wants us to write declarative specifications from which we can automatically /extract/ the operational code for SAFEs, or any other financial contract, or any other contract at all! The instance "comes out of" the class. We want the class to "come out of" the rules.

Following that instinct, in the Advanced Approach section, we will take a step back and encode the SAFE template itself in a higher-level /declarative/ form. We will know we are successful when, having written up the SAFE in our DSL, we can automatically compile it to a natural language representation of the rules that looks similar to the original text of the SAFE, and to an operational implementation that looks like the output of the above operational exercise. This is an exercise in Model-Driven Engineering, and is similar in spirit to what code generators do from UML; in the past, people did it with SBVR. In one of our exercises we will do it from DMN. Formal methods allow us to do useful things at the level of declarative specifications, that cannot be done at the level of individual implementations.

But enough talk, let's get started.

* <<<Basic Approach>>>: Show Me The Money
:PROPERTIES:
:header-args:haskell: :noweb-ref basictypes
:END:

First we will flesh out the exercise in Haskell. Simple Haskell, at that. Nothing fancy. Most of our functions just do addition and subtraction and multiplication. You can follow along even if you don't know Haskell. By the end, you will know a bit.

** Appendix II, Example 1

Let's turn Appendix II, Example 1 into code! Because we believe in test-driven development, we will write the tests first, and then write the code. And we will do this in a "literate programming" style, where the code in this README becomes the code that actually runs.

*** Appendix II, Example 1: in Haskell

Please open the [[https://www.ycombinator.com/assets/ycdc/Primer%20for%20post-money%20safe%20v1.1-32d79cea6fa352fe6578b492bd285240b3421fd721d2e268ca9b8c8e391e86f7.docx][SAFE User Guide]] to page 19.

#+begin_quote
ABC, Inc. (the “Company”) raised $1,000,000 from two investors.  Investor A purchased a $200,000 safe at a $4m post-money valuation cap safe and Investor B purchased an $800,000 safe at an $8m post-money valuation cap.  
#+end_quote

Let's record that information in two variables, ~safe_a~ and ~safe_b~.

#+begin_src haskell :noweb-ref test-setup
safe_a = SAFE { owner="Investor A", money_in=200000, discount=Nothing, val_cap=(Just 4000000) }
safe_b = SAFE         "Investor B"           800000           Nothing          (Just 8000000)
#+end_src

**** Question 1: What is the estimated dilution from these two safes?

Because the safes have a valuation cap, we can compute the minimum expected dilution. If the safes didn't have a cap, we wouldn't be able to answer that question with only the information we have so far, because the dilution depends on the valuation from Series A, which we haven't been given yet.

The user guide says
#+begin_quote
At this point, the Company has sold a minimum of 15% to investors. 
#+end_quote

OK, we'll define our test accordingly, for a new function we'll call ~estimatedDilution~.

#+begin_src haskell :noweb-ref test-1
  describe "estimatedDilution" $ do
    it "should compute the expected minimum dilution from II.1 as 15%" $
      estimatedDilution [safe_a, safe_b] `shouldBe` 15 / 100
#+end_src

The user guide helpfully explains how it arrived at 15%:

#+begin_quote
Investor A = $200,000 / $4,000,000 = 5%

Investor B = $800,000 / $8,000,000 = 10%
#+end_quote

From this, we gather that "dilution" is a thing that is expressed as a percentage. Here, it's calculated as ~money_in / val_cap~.

To get to the desired answer -- 15% total -- we'll take the sum of the individual dilutions.

#+begin_src haskell :noweb-ref basicimplementation
estimatedDilution :: [Security] -> Float
estimatedDilution safes =
  sum [ money / cap
      | SAFE{money_in=money, val_cap=(Just cap)} <- safes ]
#+end_src

If you're new to Haskell, you can read this as "the sum of all the ~money_in / val_cap~ of all the safes". If a SAFE doesn't have a val_cap, it gets left out of the calculation. The User Guide takes a shortcut: it knows it's dealing with cap-only, no-discount SAFEs, so it cuts to the chase. But the solution isn't generalizable. What's the estimated dilution for a discount-only, no-cap SAFE? There isn't one! If the next round issues at super-low valuation, the dilution could creep close to 100%.

The solution: calculate actual dilution, given a valuation.

To be able to break out the 5% and the 10%, we need to deal with each SAFE on its own. Let's call that "dilutionDueTo".

#+begin_src haskell :noweb-ref test-1
  describe "dilutionDueTo" $ do
    it "should be  5% for investor A" $ dilutionDueTo (valuationPre series_a) safe_a `shouldBe` 0.05
    it "should be 10% for investor B" $ dilutionDueTo (valuationPre series_a) safe_b `shouldBe` 0.10
#+end_src

I want ~dilutionDueTo~ to handle the full complexity of an individual SAFE's conversion, handling each of the four variants (cap/discount, no-cap/no-discount) correctly under different valuation scenarios in the Equity Financing.

To do that, ~dilutionDueTo~ needs to know the Series A pre-money valuation.

That means the function needs to have at least two arguments: the Series A pre-money valuation, and the specifics of the SAFE.

#+begin_src haskell :noweb-ref basicimplementation

dilutionDueTo :: Money -> Security -> Percentage
dilutionDueTo valuationPre safe = safe.money_in / effectiveValuation valuationPre safe
#+end_src

Haskell is strongly typed. In this function, we use ~Money~ as the type of the valuation, and Percentage as the type of the result. Under the hood both are Floats. The type alias keeps them conceptually separated. 

#+begin_src haskell :noweb-ref basictypes
type Percentage = Float
type      Money = Float
#+end_src

(In the real world, we would augment Money with a currency label, and to avoid floating-point errors we should use an Integer number of cents. Percentage would be a Rational instead of a Float. but because this is just a learning exercise we will keep things simple and do everything with Floats.)

Each SAFE converts at a certain /effective valuation/, which is based on, but usually different to, the Series A pre-money valuation.

It all depends on which of the four variants the SAFE belongs to. We'll set up a ~case~ statement, aka a ~switch~ statement, to handle the four possibilities:

#+begin_src haskell :noweb-ref basicimplementation :noexpand
effectiveValuation valuationPre safe = case (safe.discount, safe.val_cap) of
#+end_src

If the SAFE is no-discount, no-cap, then the effective valuation is just the Series A pre-money valuation.

#+begin_src haskell :noweb-ref basicimplementation
                         (Nothing, Nothing) -> valuationPre
#+end_src

If the SAFE is cap, no-discount, we take the ~val_cap~ as the effective valuation.

#+begin_src haskell :noweb-ref basicimplementation
                         (Nothing, Just _ ) ->     cappedValuation
#+end_src

If the SAFE is discount, no-cap, we reduce the Series A pre-money valuation by give SAFE's discount, and use the result.

#+begin_src haskell :noweb-ref basicimplementation
                         (Just _,  Nothing) ->                     discountedValuation
#+end_src

If the SAFE has both cap and discount, we take whichever valuation is lower -- ~min~ means "minumum".

#+begin_src haskell :noweb-ref basicimplementation
                         (Just _,  Just _ ) -> min cappedValuation discountedValuation
#+end_src

A couple of helper functions make the math easier: here's how we arrived at the ~cappedValuation~ used above.

#+begin_src haskell :noweb-ref basicimplementation
    where
           cappedValuation     = min (val_cap safe) (Just valuationPre) // valuationPre
#+end_src

And here's how we arrived at the ~discountedValuation~ we used above:

#+begin_src haskell :noweb-ref basicimplementation
           discountRate        = 1 - discount safe // 0
           discountedValuation = discountRate * valuationPre
#+end_src

With all that math worked out in advance, we are now ready to return the dilution proper. Whereas ~estimatedDilution~ above calculated it as ~money_in / val_cap~, we now realize that the ~val_cap~ denominator there was a hand-wave for the more correct ~effectiveValuation~. Now we can do it right:

Observant Haskellers will say, "wait, what's ~//~?" You got me. It's syntactic sugar for ~fromMaybe~, borrowed from Perl's [[https://www.effectiveperlprogramming.com/2010/10/set-default-values-with-the-defined-or-operator/][defined-or operator]]. You can think of it as "iff the left-hand-side is undefined, then use the value on the right". It's a bit like ~||~ meaning "or", but with a twist. The difference between ~//~ and ~||~ will be appreciated by anyone who has ever been bitten by a truthiness bug, in which code that meant to test for ~undefined~ accidentally matched on a defined ~0~ value.

#+begin_src haskell :noweb-ref hsutils
infixl 7 //
(//) = flip fromMaybe
#+end_src

One more remark: The term "cap" can be confusing.
1. A /Company Capitalization/ is measured in number of shares; it is a total of all the shares in the company at a certain point in the conversion process. A table showing all the shareholders is a "Capitalization Table" or "Cap Table" for short. The User Guide examples contain quite a few.
2. A /Valuation Cap/ is a limit on the effective valuation, an upper bound. So it is a cap, like the cap you wear on the top of your head. The amount is capped.

Anyway, where were we?

We were calculating that Investor A will get 5% and Investor B will get 10%, and we were being exhaustively comprehensive about the conversion dilution.

Hmm. If we don't speed up a little, we're going to be here all day.

#+begin_quote
The Company issued a pro rata side letter to Investor B, giving this investor the right to purchase 10% of the new money being raised in the next Equity Financing.  For example, if the Company raises a $5m Series A, Investor B would have a contractual right to invest up to $500k. 
#+end_quote

Tell you what, we'll deal with the pro-rata side letter properly in the Advanced Approach. For now, we'll just treat Investor B as part of the new money, as far as the Series A is concerned.

**** Question 2: What is the impact of an Equity Financing on the Company’s cap table?

Earlier, when we defined ~safe_a~ and ~safe_b~, we used record syntax, which should have given you enough to go on. Now it's time to define types explicitly. Since we're coming up on a Series A, let's give ourselves a way to talk about both SAFEs and equity securities:

#+begin_src haskell basictypes
data Security = SAFE { owner    :: Entity       -- who purchased this safe
                     , money_in :: Money        -- how much money did the investor put in?
                     , discount :: Maybe Float  -- usually something like 20%
                     , val_cap  :: Maybe Money  -- usually something like US$10,000,000
                     }
              | Equity { owner      :: Entity
                       , money_in   :: Money
                       , shareClass :: String   -- "A" or "B" or "Seed" depending on the Series
                       }
              deriving (Show, Eq)
#+end_src

If you're not an experienced Haskeller, the "Maybe" type may be unfamiliar. We need it to represent the concept that SAFEs have four subtypes, based on whether they have discounts and caps.

To represent the idea that those attributes are optional, some languages (which will remain unnamed to protect the guilty) might say

#+begin_src typescript
interface SAFE { ... discount?: number; ... }
#+end_src

to indicate that a SAFE object doesn't need to have a ~discount~ attribute.

Another approach is to always set the discount attribute, and treat it as a number most of the time, but set it to ~undefined~ when the SAFE is one of the no-discount variants.

#+begin_src typescript
interface SAFE { ... discount: number | null; ... }
#+end_src

"Think it about it," they will argue, "if there is no discount on the SAFE, ~undefined~ will be treated as ~0~, which gives the right answer when you do ~discountRate = 1 - discount~."

And they would be right -- as far as discounts go. But treating an undefined valuation cap as 0 is going to blow up when you divide by zero. This is why [[https://medium.com/@hinchman_amanda/null-pointer-references-the-billion-dollar-mistake-1e616534d485][Tony Hoare called "null" his "billion dollar mistake]]".

In Haskell, we explicitly wrap the number inside a ~Maybe~. If a SAFE has 10% discount, no-cap, we would say ~discount=Just 10%~ and ~val_cap=Nothing~. That's more formal and structured, and that's the reason we defined ~//~ to give defaults to ~Nothing~ values.

We use a plain old string to label the owner, though in a real world application an Owner would have an address and ID numbers and email.

#+begin_src haskell :noweb-ref basictypes
type Entity = String -- simple type alias, nothing to see here
#+end_src

Now we are given more information to work with:

#+begin_quote
The Company signed a Series A term sheet to raise $5m at a pre-money valuation of $15m (which pre-money valuation includes (i) an ungranted and unallocated employee option pool representing 10% of the fully-diluted post-closing capitalization and (ii) all shares of Company capital stock issued in respect of outstanding safes and/or convertible promissory notes), resulting in a post-money valuation of $20m.  Investor C, the lead investor, will be investing $4m for 20% post-closing fully diluted ownership.
#+end_quote

We represent that word problem with the following record:

#+begin_src haskell :noweb-ref test-setup
series_a = EquityRound { valuationPre = 15000000
                       , new_money_in =  5000000
                       , commonPre    =  9250000
                       , optionsPreOutstanding = 300000
                       , optionsPrePromised    = 350000
                       , optionsPreFree = 100000
                       , optionsPost  = 10 / 100
                       , convertibles = [safe_a, safe_b]
                       , incoming     = [seriesA_c, seriesA_b, seriesA_other]
                       }

seriesA_c     = Equity { owner="Investor C", money_in=4000000,   shareClass="A" }
seriesA_b     = Equity { owner="Investor B", money_in=499998.97, shareClass="A" }
seriesA_other = Equity "Other New Investors"          500001.19             "A"
#+end_src

(Half a million dollars from "other investors" shows up in the cap table, hence ~seriesA_other~.)

In an OOP language we would say that ~series_a~ is a variable pointing to an object which is an instance of a class.

In Haskell we say that ~series_a~ is a value returning a record which inhabits a type.

#+begin_src haskell :noweb-ref basictypes
data EquityRound = EquityRound { valuationPre   :: Money       -- what pre-money valuation was negotiated and agreed with new investors?
                               , new_money_in   :: Money       -- how much fresh money is coming in?
                               , commonPre      :: Int         -- how many ordinary shares did the company issue immediately prior to the round?
                               , optionsPreOutstanding :: Int  -- what options pool was previously allocated and issued?
                               , optionsPrePromised    :: Int  -- what options pool was previously allocated and promised, but not yet issued?
                               , optionsPreFree        :: Int  -- what options pool was previously allocated but not spoken for?
                               , optionsPost    :: Float       -- what pool is being set aside in this round, as a percentage of post?
                               , convertibles   :: [Security]  -- this round may cause the conversion of some existing SAFEs, etc
                               , incoming       :: [Security]  -- and we know that some investors have already committed.
                               } deriving (Show, Eq)
#+END_SRC

Here, we use "pre" and "post" to refer to before and after the round closes.

The User Guide mentions that the ~Option pool increase~ is 1,695,000 shares, and the ~Series A price per share~ is $1.1144.

How did they arrive at those numbers? Read on...

The total number of as-if-converted shares /prior to conversion/ is the sum of the founder stock and the options in the ESOP, including the available options.

#+begin_src haskell :noweb-ref basicimplementation
sharesPre eqr = sum $ [commonPre, optionsPreOutstanding, optionsPrePromised, optionsPreFree] <*> [eqr]
#+end_src

The "immediately prior" table shows 10 million total shares at the start of the round. We'll call that ~sharesPre~.

#+begin_src haskell :noweb-ref test-1
  describe "sharesPre" $ do
    it "should show total common + option shares as 10,000,000" $
      sharesPre series_a `shouldBe` 10000000
#+end_src

**** Safe Conversion

The next step is conversion of the SAFEs:

#+begin_src
As explained in example #1 above, the Company’s outstanding post-money safes will convert into at least 15% of the Company Capitalization, which includes, without double counting, all safe and note conversion shares, the existing option pool, and all promised options, but excludes the new money shares as well as the option pool increase associated with the Equity Financing.  In this example, the safes convert into exactly 15% because the post-money valuation of the Equity Financing is sufficiently high that all safes convert into Safe Preferred Stock at a price per share based on their respective valuation caps rather than Standard Preferred Stock at the Series A price per share (see Section B, question 2 in the Q&A).
#+end_src

The equation for /Company Capitalization/ adds the conversion shares to the immediately prior ~sharesPre~. The expected answer is 11,764,705.

#+begin_src haskell :noweb-ref test-1
  describe "companyCapitalization" $ do
    it "should be 11,764,705" $
      companyCapitalization series_a `shouldBe` 11764705
#+end_src

For now, ignore the version of the function that has the little tick on the end. More on that later.

#+begin_src haskell :noweb-ref basicimplementation
companyCapitalization' eqr = sharesPre eqr + conversionSharesAll' eqr
companyCapitalization  eqr = sharesPre eqr + conversionSharesAll  eqr
#+end_src

To arrive at that number, we had to determine the number of conversion shares: 1,764,705.

#+begin_src haskell :noweb-ref test-1
  describe "conversionSharesAll" $ do
    it "conversion shares should add up to 1,764,705" $
      conversionSharesAll series_a `shouldBe` 1764705
#+end_src

#+begin_src haskell :noweb-ref basicimplementation
conversionSharesAll :: EquityRound -> Int
conversionSharesAll' eqr = ceiling $ conversionDilutions eqr * (fromIntegral (sharesPre eqr) / (1 - conversionDilutions eqr))
conversionSharesAll  eqr = sum $ conversionShares eqr <$> convertibles (eqr :: EquityRound)
#+end_src

The conversion shares were computed based on the conversion dilutions, which is the sum of all the dilution due to the SAFEs.

We already know it should be 15%, but let's reach that number in a bottom-up way.

#+begin_src haskell :noweb-ref test-1
  describe "conversionDilutions" $ do
    it "should add up to 15%" $
      conversionDilutions series_a `shouldBe` 0.15
#+end_src

#+begin_src haskell :noweb-ref basicimplementation
conversionDilutions :: EquityRound -> Float
conversionDilutions eqr =
  sum $ dilutionDueTo (eqr.valuationPre) <$> (convertibles (eqr :: EquityRound))
#+end_src

For sure, all of the above calculations could fit into a spreadsheet. Auto-generation of a spreadsheet is consistent with the goals of the Advanced Approach below.

A handful of other functions may be useful. ~conversionShares~ tells us how many shares a particular SAFE converts to.

#+begin_src haskell :noweb-ref test-1
  describe "conversionShares" $ do
    it "investor A's SAFE converts to   588,235 shares" $ conversionShares series_a safe_a `shouldBe`  588235
    it "investor B's SAFE converts to 1,176,470 shares" $ conversionShares series_a safe_b `shouldBe` 1176470
#+end_src

#+begin_src haskell :noweb-ref basicimplementation
conversionShares :: EquityRound -> Security -> Int
conversionShares eqr safe
  = floor(dilutionDueTo (eqr.valuationPre) safe * fromIntegral ( companyCapitalization' eqr ))
#+end_src

**** New Money

#+begin_quote
The Company is raising $5m at a pre-money valuation of $15m. The Series A price per share is calculated as follows.

Series A Price per Share = pre-money valuation / (total fully diluted shares post safe conversion + option pool increase)

	= $15,000,000 / (11,764,705 + 1,695,000)

	= $1.1144
#+end_quote

#+begin_src haskell :noweb-ref test-1
  describe "pricePerShare" $ do
    it "each Series A share should be priced at $1.1144" $
      pricePerShare series_a `shouldBe` 1.1144
#+end_src

But wait:

- The price per share depends on the increase in the option pool.
- The increase in the option pool depends on the number of shares issued to the Series A investors.
- The number of shares issued to the Series A investors depends on the price per share.

You will recall from high school mathematics that this is a system of simultaneous equations! We have four equations and four unknowns.

- pricePerShare = valuationPre / (companyCapitalization + optionsNewFree)
- optionsNewFree = optionsPost * totalPost - optionsPreFree
- totalPost = companyCapitalization + allInvestorIssues + optionsNewFree
- allInvestorIssues = allInvestorMoney / pricePerShare

Uppercase represent unknowns, lowercase represent knowns.
- PPS = vp / (cc + ONF)
- ONF = op * TP - opf
- TP  = cc + AII + ONF
- AII = aim / PPS

Drawing on those high-school skills, we solve the equations by hand.
(Later, we'll look at how to use a constraint solver to do the same
thing.) We solve for totalPost:

- TP = cc + (aim / PPS) + (op * TP - opf)
- TP = cc + (aim / (vp / (cc + (op * TP - opf) ) ) ) + (op * TP - opf)
- TP - (op*TP-opf) - cc = ( aim * (cc + op*TP - opf) ) / vp
- vp*TP - vp*op*TP + vp*opf - vp*cc = aim*cc + aim*op*TP - aim*opf
- vp*TP - vp*op*TP - aim*op*TP = aim*cc - aim*opf - vp*opf + vp*cc
- TP(vp - vp*op - aim*op) = ...
- TP = (aim*cc - aim*opf - vp*opf + vp*cc) / (vp - vp*op - aim*op)

From the table, we know to expect:

#+begin_src haskell :noweb-ref test-1
  describe "totalPost" $ do
    it "for example 1, rounds to 17,946,424" $ totalPost series_a `shouldBe` 17946424
#+end_src

And then we plug in the known values:

#+begin_src haskell :noweb-ref basicimplementation
totalPost' eqr =
  let cc    = fromIntegral(companyCapitalization eqr)
      vp    =              valuationPre          eqr
      op    =              optionsPost           eqr
      opf   = fromIntegral(optionsPreFree        eqr)
      aim   =              allInvestorMoney      eqr
  in
    floor ( (aim*cc - aim*opf - vp*opf + vp*cc) / (vp - vp*op - aim*op) )
#+end_src

Well, guess what. Our code returns 17,945,702, but the test expects 17,946,424. This is due to rounding error:

| term                  | user guide | our code   |    delta | delta % |
|-----------------------+------------+------------+----------+---------|
| totalPost             | 17,946,424 | 17,945,702 |      722 |  0.004% |
| pricePerShare         | 1.1144     | 1.114473   | 0.000073 | 0.0065% |
| optionsNewFree        | 1,695,000  | 1,694,570  |      430 |  0.025% |
| allInvestorIssues     | 4,486,719  | 4,486,424  |      286 | 0.0006% |
| Investor C shares     | 3,589,375  | 3,589,140  |      236 | 0.0006% |
| Investor B shares     | 448,671    | 448,641    |       30 | 0.0006% |
| Other investor shares | 448,673    | 448,643    |       30 | 0.0006% |

Well, that's why we called it totalPost' -- as in "prime". We'll run
one set of "prime" calculations, then deliberately and arbitrarily
drop significant digits (welcome to corporate finance!) to get numbers
that come out the same as the User Guide. The "prime" functions in the
prior section were helper functions serving much the same purpose: to
first get an exact answer with too many significant digits, which we
can then round off to obtain final numbers.

#+begin_src haskell :noweb-ref test-1
  describe "totalPost'" $ do
    it "for example 1, more precisely, should be 17,945,700 " $ totalPost' series_a `shouldBe` 17945700
#+end_src

We relied on ~allInvestorMoney~, one of the known terms in the equation:

#+begin_src haskell :noweb-ref basicimplementation
allInvestorMoney :: EquityRound -> Money
allInvestorMoney eqr
  = sum $ money_in <$> incoming eqr
#+end_src

We define the other functions in terms of the knowns:

#+begin_src haskell :noweb-ref test-1
  describe "optionsNewFree'" $ do
    it "if we were being precise we would issue 1,694,570 new options to arrive at a new pool sized at 10%" $ optionsNewFree' series_a `shouldBe` 1694570
  describe "optionsNewFree" $ do
    it "if we're rounding to the nearest thousand, we would issue 1,695,000 new options to arrive at a new pool sized at 10%" $ optionsNewFree series_a `shouldBe` 1695000
#+end_src

#+begin_src haskell :noweb-ref basicimplementation
optionsNewFree' :: EquityRound -> Int
optionsNewFree' eqr
  = floor (optionsPost eqr * fromIntegral(totalPost' eqr)) - optionsPreFree eqr

pricePerShare' :: EquityRound -> Money
pricePerShare' eqr
  = valuationPre eqr / fromIntegral (companyCapitalization eqr + optionsNewFree' eqr)
#+end_src

Now we back our way into the numbers shown in the user guide, doing some violence along the way with liberal rounding:

#+begin_src haskell :noweb-ref basicimplementation
pricePerShare :: EquityRound -> Money
pricePerShare eqr = fromIntegral(floor(pricePerShare' eqr * 10000)) / 10000

optionsNewFree :: EquityRound -> Int
optionsNewFree eqr = floor000( round(valuationPre eqr / pricePerShare eqr) - companyCapitalization eqr )

floor000 n = n `div` 1000 * 1000

totalPost :: EquityRound -> Int
totalPost eqr = companyCapitalization eqr + allInvestorIssues eqr + optionsNewFree eqr
#+end_src

#+begin_quote
The Company will sell 4,486,719 shares of Series A Preferred Stock ($5,000,000 divided by the Series A price per share of $1.1144).  Investor C, the lead investor, will purchase 3,589,375 shares ($4,000,000 divided by $1.1144) and Investor B will exercise its pro rata right. 
#+end_quote

That's enough information to set up a couple of tests:

#+begin_src haskell :noweb-ref test-1
  describe "investorIssue" $ do
    it "investor C gets 3,589,375 shares for $4,000,000 "    $ investorIssue series_a seriesA_c `shouldBe` 3589375
    it "investor B gets   448,671 shares for $  499,998.97 " $ investorIssue series_a seriesA_b `shouldBe`  448671
    it "the others get    448,673 shares"                    $ investorIssue series_a seriesA_other `shouldBe`  448673
#+end_src

We know about Investor B from:

#+begin_quote
Investor B’s pro rata = Total Series A Shares * pro rata ownership percentage

	= 4,486,719 * 10%

	= 448,671 shares of Series A Preferred Stock for $499,998.97
#+end_quote

To pass that test, let's define ~investorIssue~ to calculate the number of shares an incoming investor receives.

#+begin_src haskell :noweb-ref basicimplementation
investorIssue' :: EquityRound -> Security -> Int
investorIssue' eqr investment = floor (money_in investment / pricePerShare' eqr)
investorIssue  eqr investment = floor (money_in investment / pricePerShare  eqr)
#+end_src

#+begin_src haskell :noweb-ref test-1
  describe "allInvestorIssues" $ do
    it "together, the new money turns into 4,486,719 shares " $ allInvestorIssues series_a `shouldBe` 4486719
#+end_src

#+begin_src haskell :noweb-ref basicimplementation
allInvestorIssues' :: EquityRound -> Int
allInvestorIssues' eqr = sum $ investorIssue' eqr <$> incoming eqr
allInvestorIssues  eqr = sum $ investorIssue  eqr <$> incoming eqr
#+end_src

What percentage of ~totalPost~ is the available option pool?

#+begin_src haskell :noweb-ref test-1
  describe "optionsNewFree" $ do
    it "should add with optionsPreFree to make 1,795,000" $
      optionsNewFree series_a + optionsPreFree series_a `shouldBe` 1795000
  describe "optionsPost" $ do
    it "should come out to 10.00% " $
      floor(1000 * fromIntegral(optionsNewFree series_a + optionsPreFree series_a) / fromIntegral(totalPost series_a)) `shouldBe` floor(optionsPost series_a * 1000)
#+end_src

**** Standard Preferred vs Safe Preferred Stock
Our treatment of this example declines to address the matter of Standard vs Safe Preferred Stock from page 21. We'll get to it in Advanced Approach below.
**** Question 3: What happens to the safes if the Company is acquired for $10m prior to an Equity Financing?

#+begin_quote
The Company receives a proposal to be acquired for $10m in cash. Immediately prior to the acquisition, the Company’s cap table looks as follows: ...
#+end_quote

You know the drill: we set up the scenario.
#+begin_src haskell :noweb-ref test-setup
exit10 = LiquidityEvent { liquidityPrice = 10000000
                        , common         =  9250000
                        , optionsUsed    =   300000
                        , optionsFree    =   450000
                        , convertibles   = [safe_a, safe_b]
                        }
#+end_src

And we set up the type:
#+begin_src haskell :noweb-ref basictypes
data Scenario = LiquidityEvent { liquidityPrice :: Money
                               , common         :: Int
                               , optionsUsed    :: Int
                               , optionsFree    :: Int
                               , convertibles   :: [Security]
                               } deriving (Show, Eq)
#+end_src

The user guide tells us how to think about this:

#+begin_quote
In this /Liquidity Event/, the individual safe holders will automatically receive the greater of their /Purchase Amount/ (the “Cash-Out Amount”) or the amount payable on their /Conversion Amount/, the number of shares of Common Stock equal to the /Purchase Amount/ divided by the /Liquidity Price/. 
#+end_quote

We turn the information we are given into tests:

#+begin_src haskell :noweb-ref test-1
--  describe "conversionAmount" $ do
--    it "investor A's Conversion Amount is   561,764 shares" $ conversionAmountShares exit10 safe_a `shouldBe`  561764
--    it "investor B's Conversion Amount is 1,123,527 shares" $ conversionAmountShares exit10 safe_b `shouldBe` 1123529
--  describe "exitPricePerShare" $ do
--    it "should be $0.8901" $ exitPricePerShare exit10 `shouldBe` 0.8901
#+end_src

But we will implement the operational logic using a constraint solver, because the Liquidity Capitalization definition is mutually recursive.


**** Notes

The ~new_money_in~ is an upper bound. In practice the round may not fill, in which case the investors will get slightly more % of the company than they had originally negotiated; while the absolute size of your slice of the pie remains the same, because the pie itself is smaller, it's a greater portion, relatively speaking.


*** Constraints: in Haskell didn't work

We can phrase all of the above mathematics in the form of constraints. Math.MFSolve lets us say:

#+begin_src haskell :noweb-ref exclude
asConstraints eqr =
  let aim :: Expr SimpleVar Float
      [ aim,  -- all investor money
        aii,  -- all investor issues
        cc,   -- company capitalization
        sp,   -- shares Pre conversion
        csa,  -- conversion shares all
        vp,   -- valuationPre
        op,   -- optionsPost
        onf,  -- optionsNewFree
        opf,  -- optionsPreFree
        tp,   -- totalPost
        pps ] -- pricePerShare
        = map (makeVariable . SimpleVar) (words "aim aii cc sp csa vp op onf opf tp pps")
  in showVars $ flip execSolver noDeps $ do
     aim === makeConstant (allInvestorMoney eqr)
     aii === aim / pps
     cc  === sp + csa
     sp  === makeConstant (fromIntegral (sharesPre eqr))
     csa === makeConstant (fromIntegral (conversionSharesAll eqr))
     vp  === makeConstant (valuationPre eqr)
     op  === makeConstant (optionsPost eqr)
     onf === op * tp - opf
     opf === makeConstant (fromIntegral (optionsPreFree eqr))
     tp  === cc + aii + onf
     pps === vp / (cc + onf)
#+end_src

Solving this gets us most of the way; we need to minimize the final equation:

#+begin_src text
*Main Lib SAFE.Basic> asConstraints series_a
csa = 1764705.0
opf = 100000.0
sp = 1.0e7
aim = 5000000.0
vp = 1.5e7
cc = 1.1764705e7
op = 0.1
aii = -1.1664705e7 + 0.9*tp
onf = -100000.0 + 0.1*tp
pps - 1.5e7/(1.1664705e7 + 0.1*tp) = 0
-1.1664705e7 + 0.9*tp - 5000000.0/pps = 0
#+end_src

*** Constraints: Prolog / CLP(R) didn't work

In this section we try Prolog. Unfortunately CLPR(Q,R) isn't up to solving this particular problem.

#+begin_src prolog :noweb-ref lineq

  test1(Convertibles, SeriesA) :-
      Convertibles = [ Safe_A, Safe_B ],
      SeriesA = eqr{valuationPre:   15000000,
		    new_money_in:    5000000,
		    commonPre:       9250000,
                    optionsPreOutstanding: 300000,
		    optionsPrePromised:    350000,
                    optionsPreFree: 100000,
                    optionsPost:    10 / 100,
                    convertibles:   [Safe_A, Safe_B],
                    incoming:       [SeriesA_c, SeriesA_b, SeriesA_other]
		   },
      SeriesA_c     = equity{owner:"Investor C", money_in:4000000,   shareClass:"A"},
      SeriesA_b     = equity{owner:"Investor B", money_in:499998.97, shareClass:"A"},
      SeriesA_other = equity{owner:"Other New Investors", money_in:500001.19, shareClass:"A"},
      Safe_A        =   safe{owner:"Investor A", money_in:200000, val_cap:4000000},
      Safe_B        =   safe{owner:"Investor B", money_in:800000, val_cap:8000000}.

dilutionDueTo(ValPre, Safe, Dil, Log) :- effectiveValuation(ValPre, Safe, EffVal, Log),
					 Dil = Safe.money_in / EffVal.

effectiveValuation(ValPre, safe{owner:O, money_in: _                          }, EffVal, Log) :- EffVal = ValPre,
												  string_concat(O, ": no cap no discount", Log).
effectiveValuation(ValPre, safe{owner:O, money_in: _,              val_cap: PC}, EffVal, Log) :- ( ValPre <  PC -> EffVal = ValPre; EffVal = PC ),
												  string_concat(O, ": cap no discount", Log).
effectiveValuation(ValPre, safe{owner:O, money_in: _, discount: D             }, EffVal, Log) :- EffVal = (ValPre * (1-D)),
												  string_concat(O, ": discount no cap", Log).
effectiveValuation(ValPre, safe{owner:O, money_in: _, discount: D, val_cap: PC}, EffVal, Log) :- Discounted = (ValPre * (1-D)),
												  ( Discounted <  PC -> EffVal = Discounted ;  EffVal = PC),
												  string_concat(O, ": cap and discount", Log).

%% 0.15
conversionDilutions(Convertibles, ValPre, DilPercentage) :-
    maplist({ValPre}/[Convertible, Dil, Log]>>dilutionDueTo(ValPre,Convertible,Dil,Log), Convertibles, Dils, Logs),
    foldl(add,Dils,0,DilPercentage),
    forall(nth1(I, Logs, LogLine), print_message(informational, conversion_dilution(LogLine))).

conversionShares(SeriesA,CC_Roughly,Safe,NumConversionShares) :-
    dilutionDueTo(SeriesA.valuationPre, Safe, Dil, Log),
    { NumConversionShares = Dil * CC_Roughly }.

getMoneyIn(Incoming,MI) :- Incoming.money_in = MI.

conversion(SeriesA,CompanyCapitalization,ConversionSharesAll) :-
    format('* attempting conversion calculations for Series A~n', []),
    conversionDilutions(SeriesA.convertibles,SeriesA.valuationPre,DilPercentage),
    format('** dilutions are total ~w~n', [DilPercentage]),
    { SharesPre = (SeriesA.commonPre + SeriesA.optionsPreOutstanding + SeriesA.optionsPrePromised + SeriesA.optionsPreFree) },
    format('** SharesPre = ~w~n', [SharesPre]),
    { ConversionSharesAll = DilPercentage * SharesPre / (1 - DilPercentage) },
    format('** computed conversion shares = ~w~n', [ConversionSharesAll]),
    { CompanyCapitalization = SharesPre + ConversionSharesAll },
    format('** computed company capitalization = ~w~n', [CompanyCapitalization]),
    maplist(getMoneyIn, SeriesA.incoming, MIlist),
    sum_list(MIlist, AllInvestorMoney),
    format('** computed AllInvestorMoney = ~w~n', [AllInvestorMoney]),
    {
    TotalPost = CompanyCapitalization + AllInvestorIssues + OptionsNewFree,
    TotalPost > 0,
    OptionsNewFree = SeriesA.optionsPost * TotalPost - SeriesA.optionsPreFree,
    PricePerShare = SeriesA.valuationPre / ( CompanyCapitalization + OptionsNewFree ),
    AllInvestorIssues = AllInvestorMoney / PricePerShare
    },
    format('** computed pricePerShare = ~w, totalPost = ~w~n', [PricePerShare, TotalPost])
.

  :- multifile prolog:message//1.
  prolog:message(conversion_dilution(LogLine)) -->
      [ LogLine ].

  main :- test1(Convertibles, SeriesA), conversion(SeriesA,CC,NCSA).

  add(X,Y,Sum) :- Sum is X+Y.
#+end_src

Sadly, the CLP(Q,R) library is unable to solve the simultaneous equations.

*** Constraints: Curry didn't work

Curry was also unable to solve the simultaneous equations. We include the Curry code to show the syntax:

#+begin_src curry
conversion eqr
  | sPre == i2f( commonPre eqr + optionsPreOutstanding eqr + optionsPrePromised eqr + optionsPreFree eqr )
  & valPre == valuationPre eqr
  & cc    =:= sPre + csall
  & csall =:= (dilutionDueTo valPre safe_a * cc + dilutionDueTo valPre safe_b * cc)
  & pps   =:= valuationPre eqr / (cc + onf)
  & onf   =:= optionsPost eqr * tp - i2f(optionsPreFree eqr)
  & tp    =:= cc + aii + onf
  & aii   =:= allInvestorMoney eqr / pps
  = [ "totalPost = " ++ show tp ]
  where sPre, valPre, cc, pps, onf, tp, aii, csall free
        convShares safe = dilutionDueTo (valuationPre eqr) safe * cc
#+end_src

*** Constraints: Z3 worked

This is straight-up Z3 in SMT-LIB format. Basically, Lisp S-expressions. Super verbose. 

#+begin_src z3 :tangle safe.z3
;; utility functions
(define-fun max ((x Real) (y Real)) Real (ite (> x y) x y))
(define-fun min ((x Real) (y Real)) Real (ite (< x y) x y))

(define-fun dilutionDueTo
    ((valuationPre Real) (safe_money_in Real) (safe_has_discount Bool) (safe_has_val_cap Bool) (safe_discount Real) (safe_val_cap Real))
    Real
    (ite       (and (= safe_has_discount false) (= safe_has_val_cap false)) (/ safe_money_in valuationPre)
      (ite     (and (= safe_has_discount false) (= safe_has_val_cap true )) (/ safe_money_in (ite (< valuationPre safe_val_cap) valuationPre safe_val_cap))
	(ite   (and (= safe_has_discount true ) (= safe_has_val_cap false)) (/ safe_money_in (* valuationPre (- 1 safe_discount)))
	       (                                                             / safe_money_in (min (ite (< valuationPre safe_val_cap) valuationPre safe_val_cap)
												  (* valuationPre (- 1 safe_discount))))
	  ))))

;; we set up the problem with some known values
(declare-const safe_A_money_in Real) (declare-const safe_A_val_cap  Real) (declare-const safe_A_has_discount Bool) (declare-const safe_A_has_val_cap Bool)
(declare-const safe_B_money_in Real) (declare-const safe_B_val_cap  Real) (declare-const safe_B_has_discount Bool) (declare-const safe_B_has_val_cap Bool)
(assert (= safe_A_money_in 200000)) (assert (= safe_A_has_discount false)) (assert (= safe_A_has_val_cap true)) (assert (= safe_A_val_cap 4000000))
(assert (= safe_B_money_in 800000)) (assert (= safe_B_has_discount false)) (assert (= safe_B_has_val_cap true)) (assert (= safe_B_val_cap 8000000))

(declare-const seriesA_valuationPre          Real) (assert (= seriesA_valuationPre        15000000))
(declare-const seriesA_new_money_in          Real) (assert (= seriesA_new_money_in         5000000))
(declare-const seriesA_commonPre             Real) (assert (= seriesA_commonPre            9250000))
(declare-const seriesA_optionsPreOutstanding Real) (assert (= seriesA_optionsPreOutstanding 300000))
(declare-const seriesA_optionsPrePromised    Real) (assert (= seriesA_optionsPrePromised    350000))
(declare-const seriesA_optionsPreFree        Real) (assert (= seriesA_optionsPreFree        100000))
(declare-const seriesA_optionsPost           Real) (assert (= seriesA_optionsPost           0.10))

(declare-const seriesA_c_money_in            Real) (assert (= seriesA_c_money_in            4000000.0))
(declare-const seriesA_b_money_in            Real) (assert (= seriesA_b_money_in             499998.97))
(declare-const seriesA_other_money_in        Real) (assert (= seriesA_other_money_in         500001.19))

;; we do a quick check on the dilution numbers
(declare-const ddA Real)
(assert (= ddA (dilutionDueTo seriesA_valuationPre safe_A_money_in safe_A_has_discount safe_A_has_val_cap 0 safe_A_val_cap)))
(declare-const ddB Real)
(assert (= ddB (dilutionDueTo seriesA_valuationPre safe_B_money_in safe_B_has_discount safe_B_has_val_cap 0 safe_B_val_cap)))

;; now we set up the simultaneous equations
(declare-const conversionDilutions   Real)
(declare-const sharesPre             Real)
(declare-const conversionSharesAll   Real)
(declare-const companyCapitalization Real)
(declare-const pricePerShare         Real)
(declare-const optionsNewFree        Real)
(declare-const totalPost             Real)
(declare-const allInvestorIssues     Real)
(declare-const allInvestorMoney      Real)

(assert (= conversionDilutions (+ (dilutionDueTo seriesA_valuationPre safe_A_money_in safe_A_has_discount safe_A_has_val_cap 0 safe_A_val_cap)
				  (dilutionDueTo seriesA_valuationPre safe_B_money_in safe_B_has_discount safe_B_has_val_cap 0 safe_B_val_cap))))
(assert (= sharesPre             (+ seriesA_commonPre seriesA_optionsPreOutstanding seriesA_optionsPrePromised seriesA_optionsPreFree)))
(assert (= conversionSharesAll   (* conversionDilutions companyCapitalization)))
(assert (= companyCapitalization (+ sharesPre conversionSharesAll)))
(assert (= allInvestorMoney      (+ seriesA_c_money_in seriesA_b_money_in seriesA_other_money_in)))
(assert (= pricePerShare         (/ seriesA_valuationPre (+ companyCapitalization optionsNewFree))))
(assert (= optionsNewFree        (- (* seriesA_optionsPost totalPost) seriesA_optionsPreFree)))
(assert (= totalPost             (+ companyCapitalization allInvestorIssues optionsNewFree)))
(assert (> totalPost             0))
(assert (= allInvestorIssues     (/ allInvestorMoney pricePerShare)))

(check-sat)
(get-model)

(get-value (totalPost))

#+end_src

There was a problem with the ~define-fun dilutionDueTo~ which required manual application of [[https://github.com/Z3Prover/z3/commit/eab7ae58bec086583f630d8d4e4a5b4b4ac294e1][a patch to the Z3 source code]]. SMH.

The good news: Z3 succeeded where CLP(R) and Curry failed!

Anyway, the result:

#+begin_src text
$ z3 safe.z3
sat
(model
  (define-fun optionsNewFree () Real
    (/ 7802083400000000.0 4604166661.0))
  (define-fun conversionSharesAll () Real
    (/ 30000000.0 17.0))
  (define-fun totalPost () Real
    (/ 82625000661000000.0 4604166661.0))
  (define-fun allInvestorIssues () Real
    (/ 20656250661000000.0 4604166661.0))
  (define-fun pricePerShare () Real
    (/ 4604166661.0 4131250000.0))
  (define-fun allInvestorMoney () Real
    (/ 125000004.0 25.0))
  (define-fun companyCapitalization () Real
    (/ 200000000.0 17.0))
  (define-fun sharesPre () Real
    10000000.0)
  (define-fun conversionDilutions () Real
    (/ 3.0 20.0))
#+end_src

What do the numbers work out to?

| optionsNewFree        | 1694570.1523118692 |
| pricePerShare         | 1.1144730193040848 |
| totalPost             |  17945701.52311869 |
| companyCapitalization |  11764705.88235294 |
| conversionSharesAll   | 1764705.8823529412 |

That looks right! Note that a layer of rounding will be required to translate this to the real world -- shares are usually treated as Ints, not Floats, and people may object to having too many significant digits in a price per share.

*** Z3 from Haskell

https://github.com/IagoAbal/haskell-z3

The Haskell interface to Z3 would allow us to specify all those equations much more compactly, but the result will still be the same.

*** Conversion: DMN

We can represent the conversion logic in DMN/FEEL, in the same way that we did with Haskell. We can't expect DMN to solve the simultaneous equations. But we can get it to produce results. We use context expressions here.

The important logic is the determination of effective valuation. Whichever valuation is most investor-favourable is the one that gets used.

| safe.discount | safe.val_cap | safe.effective_valuation                 |
|---------------+--------------+------------------------------------------|
| none          | none         | series A pre-money valuation             |
| none          | -            | capped valuation                         |
| -             | none         | discounted valuation                     |
| -             | -            | min(valuation cap, discounted valuation) |

Discount Rate:

| safe.discount_rate |               |
|-----------------+---------------|
| discount        | safe.discount |
|-----------------+---------------|
| 100% - discount |               |

Discounted valuation:

| safe.discounted_valuation                    |                      |
|----------------------------------------------+----------------------|
| series A pre-money valuation                 | seriesA.valuationPre |
| discount rate                                | safe.discount_rate   |
|----------------------------------------------+----------------------|
| series A pre-money valuation * discount rate |                      |

Capped Valuation:

| safe.capped_valuation                            |                      |
|--------------------------------------------------+----------------------|
| valuation cap                                    | safe.val_cap         |
| series A pre-money valuation                     | seriesA.valuationPre |
|--------------------------------------------------+----------------------|
| min(valuation cap, series A pre-money valuation) |                      |

The conversion dilution for a particular safe:

| safe.conversionShares         |                          |
|-------------------------------+--------------------------|
| money in                      | safe.money_in            |
| effective dilution            | safe.effective_valuation |
|-------------------------------+--------------------------|
| money in / effective dilution |                          |

The sum of all the conversion dilutions:

| allConversionShares                 |
|-------------------------------------|
| safes                               |
|-------------------------------------|
| sum(safe.conversionShares <- safes) |

and so on, following the same logic as found in the Haskell above.

** Natural Language Generation

Can we, as Landin said, dress up our pidgin algebra in pidgin English to please the generals?

It should be possible to use the operational implementation to provide explanations, at the level of talking through any given scenario calculation in the style of the User Guide example walkthroughs.

*** Examples

Take text out of the Appendix II Example 1 walkthrough; we should be able to generate that text from the code above.

*** Grammars

To facilitate the extraction of natural language from the Haskell and DMN/FEEL expressions, we develop grammars.

Let's write some grammars in GF to generate the above desired example text.

* SAFE Events

We've seen how the conversion logic can be represented in Haskell, Z3, and DMN.

But conversion is only one scenario.

Other events may trigger the SAFE in different ways.

Let's look at how DMN can help answer the question "has an X event happened?"

** Dissolution Event

** Liquidity Event

** Conversion Event

** Other Events?

Absence of repayment term.

* <<<Advanced Approach>>>
:PROPERTIES:
:header-args:haskell: :noweb-ref advanced
:END:

In this section we develop a formal model suited to representing all of the SAFE. Our approach: build a GF grammar which produces a Haskell grammar. Fill the grammars with concrete values to produce both a natural language representation of the rules and and a set of computations to embody the Basic Approach.

Ken Adams introduces various categories of contract language. We can see these categories show up in the SAFE:e

#+begin_src haskell
  data Event

  data Definition

  type Assertion = WorldState -> Bool

  data Representation = Rep Party Assertion

  data Modal = DeonticModal Party MayMustShant Action Deadline
             | EpistemicModal Party WorldState
             | TemporalModal

  faqConversion :: SAFEinstrument -> Scenario (Event SeriesA 10000000) -> WhatHappens

  -- should be a NonEmptyList
  data VersionedObject a = VO [(Date, a)] -- where "snd $ head a" is the current thing
  #+end_src

A Graph of Events and Modals

Contracts happen in time. Do you pay me first, or do I deliver the goods first? How long does an obligation last? When does the agreement expire?

To represent notions related to time, we borrow from a logic called Linear Temporal Logic: it gives us a language for talking about time. ([[https://matrix.ai/blog/programming-with-linear-temporal-logic-operators/][Short introduction]], [[https://hackage.haskell.org/package/copilot-libraries-0.1/docs/Copilot-Library-LTL.html][copilot package]].) 

We are writing a specification, not an implementation. For an example of writing specifications in a high level language, look at [[https://hackage.haskell.org/package/copilot][Copilot]]: "a stream DSL for hard real-time runtime verification". That usually brings to mind embedded systems; their example is a thermostat.

But a traditional legal contract can, with a little imagination, be considered a suitable candidate for "hard real-time runtime verification": indeed, Hvitved's thesis work, "A Trace-Based Model for Multiparty Contracts" via "Modular Implementation of Domain-Specific Languages" has a section "2.2.5 Run-time Monitoring".

Hvitved models a contract as a graph of clauses. There are several variants of clauses. The "Event" paragraph from the contract correponds to these two variants, in some BNF-like syntax I just made up with "::=" for definition and "::|" for sum-type alternatives:

#+begin_src text
Clause ::= -- I call this the "EVENT" block
           UPON action(a,x)
                WHERE  qualifyingPredicate(a,x,q)
                WITHIN deadline(a,d)
           THEN clause1
           ELSE clause2

       ::| -- I call this the "MODAL" block
           PARTY   p
           DEONTIC { Must | May | Shant }
                   action(a,x)
           WHERE   qualifyingPredicate(a,x,q)
           { NEXT | EVENTUALLY | ALWAYS }
           WITHIN  deadline(a,d1)
            AFTER  deadline(a,d2)
           THEN clause1
           ELSE clause2
#+end_src

If you are familiar with ~if/then/else~ expressions (whether as imperative control structures or as functional ternary expressions) then you should see how clauses connect via the ~THEN~ and ~ELSE~ limbs; that's how you get a graph of clauses.

The condition part of the clause is either an event trigger ("UPON ACTION") or a deontic modal specific to a party ("PARTY MUST").

In the "UPON" block, we use the terms "action" and "event" loosely interchangeably. In traditional event-driven programming (you may be familiar with Javascript Promises, for example) the program sits around and waits for things to happen. (This is also the Actor model from Erlang.) The user clicks a mouse, the user submits a form, the user calls an API, your file-read completes, some code throws an exception: all of these /events/ get /handled/. Events can also just happen "by themselves": you might say, "wait until midnight, and then do X". Events are expressed by the "UPON" syntax.

In what I call the "MODAL" block, a specific party has to do something.

That something could be an /achievement/ obligation, or a /maintenance/ obligation (this lingo is taken from LegalRuleML.)

For example, if I swear you to secrecy about some fact F, that means you have a /maintenance/ obligation to never tell anybody the fact F, forever. Or for 30 years. Or until F becomes publicly known (which we can express using a concurrent UPON block). Yes, I'm alluding to NDAs.

Another example: if you promise to pay me $1 and I promise to deliver you an apple, then we each have an /achievement/ obligation that is discharged upon performance. The language of LTL is useful to represent these *temporal* concerns: how soon do I have to deliver the apple after I receive the dollar? The keywords ~NEXT, EVENTUALLY, ALWAYS, WITHIN, AFTER, BEFORE~ help us out there.

Sometimes the achievement obligation is that I have to send you a notice informing you of a fact F. The user-defined ~action(a,x)~ might be something like ~sendNotice(to=Party2, messageContents=MC)~. This comes up pretty frequently in business.

After valid notice about F is sent to Party2, the contract is allowed to deem that Party2 now "knows" the fact F. Expressions that have to do with the sending and receiving of notices, and with knowledge generally, I call *epistemic modals*.

We can specify that something occurs forever, immediately, or eventually. Those expressions that have to with time are what I call *temporal modals*.

We can specify that somebody is obliged to, permitted to, or prohibited from doing something. Expressions that have to do with the performance of obligations are what I call *deontic modals*.

  #+begin_src haskell

  --                     if              then  else
  type ModalEventGraph = Modal (ThenElse Modal Modal)
                       | Breach    -- exit(-1), talk to a judge
                       | Fulfilled -- exit(0), all done



  data Boilerplate = Boilerplate String

  data MetaRule = MetaRule MetaRule MetaRule

  data IfThen = Upon Event Modal

  liquidityEvent = Upon liquidityEvent (EpistemicModal "send notice to Investor advising a liquidity event is happening")
    >> (DeonticModal Investor MAY RespondToEmail $ Left  (Response "yes Please" >> DeonticModal (Company MUST Pay X))
                                                   Right (Response "no thanks"  >> DeonticModal (Company MUST Pay Y))
                                                   )


  -- 	(b) Liquidity Event. If there is a Liquidity Event before the
  -- 	termination of this Safe, this Safe will automatically be
  -- 	entitled (subject to the liquidation priority set forth in
  -- 	Section 1(d) below) to receive a portion of Proceeds, due and
  -- 	payable to the Investor immediately prior to, or concurrent
  -- 	with, the consummation of such Liquidity Event, equal to the
  -- 	greater of (i) the Purchase Amount (the “Cash-Out Amount”) or
  -- 	(ii) the amount payable on the number of shares of Common
  -- 	Stock equal to the Purchase Amount divided by the Liquidity
  -- 	Price (the “Conversion Amount”).

  --                                     If any of the Company’s
  -- 	securityholders are given a choice as to the form and amount
  -- 	of Proceeds to be received in a Liquidity Event, the Investor
  -- 	will be given the same choice, provided that the Investor may
  -- 	not choose to receive a form of consideration that the
  -- 	Investor would be ineligible to receive as a result of the
  -- 	Investor’s failure to satisfy any requirement or limitation
  -- 	generally applicable to the Company’s securityholders, or
  -- 	under any applicable laws.

  -- we use the time library: https://two-wrongs.com/haskell-time-library-tutorial.html
#+end_src

** Formal Methods

Basic Approach above showed that because a SAFE conversion event involved mutually recursive definitions, it needed to be framed as a word problem in simultaneous equations. Solving those equations resulted in the "correct answer" for the SAFEs converting at Series A. This is probably why SAFEs are considered a hairball.

We know from quadratic equations that sometimes there's more than one correct answer. Could that be true here too?

Is it possible for a set of SAFEs to have more than one solution -- or no solutions at all?

Open up the cap-only, no-discount version of the SAFE (v1.1) and look at the definition of Liquidity Capitalization.

#+begin_quote
"Liquidity Capitalization" ... includes all Converting Securities, *other than* any Safes and other convertible securities (including without limitation shares of Preferred Stock) where the holders of such securities are receiving Cash-Out Amounts or similar liquidation preference payments in lieu of Conversion Amounts or similar “as-converted” payments ...
#+end_quote

My intuition tells me that this feels like a knights/knaves logic problem: "I always tell the truth, and my brother always lies. Am I lying?"

We can use formal methods to explore this intuition. Is our formalization well-suited to integration with a third-party tool like Alloy or Z3?

Do constraint problems like this arise in law and contracts elsewhere?

* Test Cases

| U | Scenario | Investment Amount | Post Money Valuation Cap | Discount | Option Pool | Series A Raise | Series A Pre-Money Val | Outcome     |
|---+----------+-------------------+--------------------------+----------+-------------+----------------+------------------------+-------------|
| 1 | e.g. 1   |            100000 |                     none |        0 |        none |                |                1000000 |             |
| 2 | II.1     |            200000 |                  4000000 |        0 |           0 |                |                        |             |
| 3 | II.1     |            800000 |                  8000000 |        0 |        0.10 |        5000000 |               15000000 | x * (1 - y) |


* Learning Objectives
** Sections of Contracts -- Types of Contract Language
*** Parameters
*** Events
*** Definitions
**** Note the evaluation of a Dividend Amount requires quite a lot of calling context.
*** Representations by Party
*** Deontics
called, in the SAFEs, "Miscellaneous"
*** Boilerplate incantations
** Transformators and Combinators
*** Hypotheticals and Counterfactuals
*** Logging Conversions of State Over Time
** Mathematical Formulae
*** constraint solving
(pre-money safes needed to be solved as a system of simultaneous equations)


* Bonus: Constraint Approaches

We could rephrase the problem in a relational style, rather than a functional style, and solve the problem as a system of constraints.

* Infrastructure
The following blobs of code help with the tangle/noweb auto-generation of Haskell code from this README.

#+NAME: tangleWarning
#+begin_src haskell
-- DO NOT EDIT THIS FILE!
-- direct edits will be clobbered.
-- 
-- this file is autogenerated by tangling ex-20200702-safe-post/README.org
-- open the README.org in emacs and hit C-c C-v t to regenerate this file.
#+end_src

#+begin_src haskell :noweb yes :tangle safepost/test/Spec.hs
{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

<<tangleWarning>>

module Main where

import Test.Hspec
import SAFE.Basic
import Data.Ratio
import Data.Maybe
import Control.Monad

main :: IO ()
main = do
  forM_ [spec1] $ hspec
  return ()

<<test-setup>>

spec1 :: Spec
spec1 = do
  <<test-1>>
#+end_src


#+begin_src haskell :noweb yes :tangle safepost/src/SAFE/Basic.hs
{-# LANGUAGE OverloadedStrings, DuplicateRecordFields, QuasiQuotes #-}
{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}

<<tangleWarning>>

module SAFE.Basic where
import Data.Ratio
import Data.Maybe

<<basictypes>>
<<basicimplementation>>
<<hsutils>>
#+end_src


#+begin_src prolog :noweb yes :tangle prolog/safe.pl
:- use_module(library(clpq)).
:- use_module(library(yall)).
<<lineq>>
#+end_src

** For emacs users

;; Local Variables:
;; org-src-preserve-indentation: t
;; End:
